package org.firstinspires.ftc.teamcode;

import com.qualcomm.robotcore.eventloop.opmode.Autonomous;
import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.hardware.CRServo;

// Programa autônomo com movimentos em metros
@Autonomous(name = "MaxClip", group = "Autônomos")
public class MaxClip extends LinearOpMode {

    private DcMotor roda_esq;
    private DcMotor roda_dir;
    private DcMotor braco;
    private DcMotor garra;
    private CRServo giro_garra;
    private CRServo coletor;

    // === CONSTANTES DO SISTEMA (ajuste conforme seu robô) ===
    private static final double DIAMETRO_RODA_CM = 10.0;           // Ex: 10 cm
    private static final double COMPRIMENTO_RODA_CM = DIAMETRO_RODA_CM * 3.1415; // Perímetro
    private static final double TICKS_POR_VOLTA = 560;             // Ex: motor com 560 ticks/volta
    private static final double TICKS_POR_CM = TICKS_POR_VOLTA / COMPRIMENTO_RODA_CM;

    private static final int TICKS_BRACO_MAX = 1500;               // Ticks do braço no topo
    private static final int TICKS_BRACO_40 = (int)(TICKS_BRACO_MAX * 0.4); // 40% da altura

    private static final double LARGURA_ROBO_CM = 30.0;            // Distância entre rodas
    private static final double TICKS_POR_GRAU = (LARGURA_ROBO_CM * 3.1415 / 360.0) * TICKS_POR_CM;

    private static final double CM_POR_M = 100; // 1 metro = 100 centímetros

    @Override
    public void runOpMode() {

        // === 1. Inicializar os componentes (conectar ao hardware) ===
        roda_esq = hardwareMap.get(DcMotor.class, "roda_esq");
        roda_dir = hardwareMap.get(DcMotor.class, "roda_dir");
        braco = hardwareMap.get(DcMotor.class, "braco");
        garra = hardwareMap.get(DcMotor.class, "garra");
        giro_garra = hardwareMap.get(CRServo.class, "giro_garra");
        coletor = hardwareMap.get(CRServo.class, "coletor");

        // === 2. Definir direção dos motores ===
        roda_esq.setDirection(DcMotor.Direction.REVERSE);
        roda_dir.setDirection(DcMotor.Direction.FORWARD);

        // === 3. Configurar encoders para movimento preciso ===
        resetarEncoders();

        // === 4. Mensagem inicial ===
        telemetry.addData("Status", "Aguardando inicio...");
        telemetry.update();

        // === 5. Esperar o início do programa ===
        waitForStart();

        if (opModeIsActive()) {

            // === 6. SEQUÊNCIA AUTÔNOMA ===

            // Levantar o braço até 40% da altura
            mostrar("Levantando braco...");
            moverMotor(braco, TICKS_BRACO_40, 0.4);
            segurarBraco(); // Força leve para segurar posição

            // Andar 3 metros para frente
            mostrar("Andando 3 metros para frente...");
            moverEmMetros(-3.0, 0.6);

            // Voltar 1.5 metro (metade da distância)
            mostrar("Voltando 1.5 metro...");
            moverEmMetros(1.5, 0.6);

            // Girar 90 graus para a direita (mais rápido)
            mostrar("Girando 90 graus...");
            girarRobo(90, 0.7);

            // Abaixar o braço
            mostrar("Abaixando braco...");
            moverMotor(braco, 0, -1.0);

            // Abrir a garra
            mostrar("Abrindo garra...");
            moverGarra(1.0, 300);

            // Girar o giro da garra
            mostrar("Girando giro da garra...");
            girarGiroGarra(1.0, 400);

            // Ligar o coletor
            mostrar("Ligando coletor...");
            ligarColetor(1.0, 1000);

            // Fechar a garra com suavidade
            mostrar("Fechando garra...");
            moverGarra(-0.6, 300);

            // Parar todos os motores
            pararTudo();
            mostrar("Missao concluida.");
            sleep(1000);
        }
    }

    // ==============================
    // MÉTODOS AUXILIARES
    // ==============================

    // Reinicia e configura os encoders
    private void resetarEncoders() {
        roda_esq.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        roda_dir.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        braco.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);

        roda_esq.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        roda_dir.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        braco.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
    }

    // Mostra mensagem no Driver Station
    private void mostrar(String texto) {
        telemetry.addData("Status", texto);
        telemetry.update();
    }

    // Move o robô em metros (negativo = frente, positivo = ré)
    private void moverEmMetros(double metros, double potencia) {
        double cm = metros * CM_POR_M;
        int ticks = (int)(cm * TICKS_POR_CM);

        roda_esq.setTargetPosition(ticks);
        roda_dir.setTargetPosition(ticks);

        roda_esq.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        roda_dir.setMode(DcMotor.RunMode.RUN_TO_POSITION);

        roda_esq.setPower(potencia);
        roda_dir.setPower(potencia);

        while (opModeIsActive() && roda_esq.isBusy() && roda_dir.isBusy()) {
            idle();
        }

        pararMotores();
    }

    // Gira o robô em graus (positivo = direita)
    private void girarRobo(double graus, double potencia) {
        int ticks = (int)(graus * TICKS_POR_GRAU);

        roda_esq.setTargetPosition(ticks);
        roda_dir.setTargetPosition(-ticks);

        roda_esq.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        roda_dir.setMode(DcMotor.RunMode.RUN_TO_POSITION);

        roda_esq.setPower(potencia);
        roda_dir.setPower(potencia);

        while (opModeIsActive() && roda_esq.isBusy() && roda_dir.isBusy()) {
            idle();
        }

        pararMotores();
    }

    // Move um motor com encoder para uma posição
    private void moverMotor(DcMotor motor, int ticks, double potencia) {
        motor.setTargetPosition(ticks);
        motor.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        motor.setPower(Math.abs(potencia));

        while (opModeIsActive() && motor.isBusy()) {
            idle();
        }

        motor.setPower(0);
    }

    // Aplica leve força no braço para evitar queda
    private void segurarBraco() {
        braco.setPower(-0.05);
        sleep(100);
    }

    // Controla a garra (abrir/fechar)
    private void moverGarra(double potencia, long tempoMs) {
        garra.setPower(potencia);
        sleep(tempoMs);
        garra.setPower(0);
    }

    // Gira o mecanismo da garra
    private void girarGiroGarra(double potencia, long tempoMs) {
        giro_garra.setPower(potencia);
        sleep(tempoMs);
        giro_garra.setPower(0);
    }

    // Liga o coletor por um tempo
    private void ligarColetor(double potencia, long tempoMs) {
        coletor.setPower(potencia);
        sleep(tempoMs);
        coletor.setPower(0);
    }

    // Para os motores de locomoção
    private void pararMotores() {
        roda_esq.setPower(0);
        roda_dir.setPower(0);
    }

    // Para todos os atuadores
    private void pararTudo() {
        pararMotores();
        braco.setPower(0);
        garra.setPower(0);
        giro_garra.setPower(0);
        coletor.setPower(0);
    }
}